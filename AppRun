#!/usr/bin/env python
import findrox; findrox.version(1, 9, 13)

import os
import rox
from rox.settings import Setting, Settings
g = rox.g

__builtins__._ = rox.i18n.translation(os.path.join(rox.app_dir, 'Messages'))

settings = Settings()
xrandr_setting = Setting('ROX/XRandRArgs', '', settings)

class Field(g.HBox):
	def __init__(self, name, sg):
		g.HBox.__init__(self, False, 4)
		label = g.Label(name)
		label.set_alignment(1, 0.5)
		sg.add_widget(label)
		self.pack_start(label, False, True, 0)
		frame = g.Frame()
		frame.set_shadow_type(g.SHADOW_IN)
		self.pack_start(frame, True, True, 0)
		self.value = g.Label('')
		frame.add(self.value)
		self.value.set_padding(2, 2)

RESPONSE_REFRESH = 1000

other_direction = {0: 0, 1: 2, 2: 1, 3: 4, 4: 3}
direction_strings = {
	0: 'same-as', 1: 'left-of', 2: 'right-of', 3: 'above', 4: 'below',
	'same-as': 0, 'left-of': 1, 'right-of': 2, 'above': 3, 'below': 4
}

class ResBox(rox.Dialog):
	def __init__(self):
		rox.Dialog.__init__(self, _("Screen Resolution"))
		self.add_button(g.STOCK_HELP, g.RESPONSE_HELP)
		self.add_button(g.STOCK_CLOSE, g.RESPONSE_CANCEL)
		self.add_button(g.STOCK_REFRESH, RESPONSE_REFRESH)
		self.add_button(g.STOCK_APPLY, g.RESPONSE_OK)
		self.set_default_response(g.RESPONSE_OK)
		self.set_has_separator(False)
		def resp(d, r):
			if r == int(g.RESPONSE_HELP):
				from rox import filer
				filer.open_dir(os.path.join(rox.app_dir, 'Help'))
			elif r == int(g.RESPONSE_OK):
				xrandr.set_modes(self.settings)
				xrandr_setting._set(' '.join(xrandr.settings_to_args(self.settings)))
				self.destroy()
				ResBox().show()
			elif r == RESPONSE_REFRESH:
				self.destroy()
				ResBox().show()
			else:
				d.destroy()
		self.connect('response', resp)

		sg = g.SizeGroup(g.SIZE_GROUP_BOTH)

		outputs_hbox = g.HBox(False, 4)
		self.vbox.pack_start(outputs_hbox, True, True, 0)

		self.settings = xrandr.get_settings(xrandr_setting.value)

		self.resolutions = {}
		self.refresh_rates = {}
		self.physical_size = {}
		self.enabled = {}
		self.directions = {}
		self.other_outputs = {}
		self.other_output_strings = {}
		self.settings_vboxes = {}

		for output, settings in sorted(self.settings.iteritems(),
									 key=lambda x: x[1].output_index):
			frame = g.Frame(output)
			self.settings_vboxes[output] = vbox = g.VBox(False, 4)
			vbox.set_border_width(5)
			vbox2 = g.VBox(False, 4)
			frame.add(vbox2)
			vbox2.pack_end(vbox)

			if len(self.settings) > 1:
				self.enabled[output] = g.CheckButton(_('Enabled'))
				self.enabled[output].set_active(settings.enabled)
				enabled_settings = [
					s for s in self.settings.itervalues() if s.enabled
				]
				self.enabled[output].set_sensitive(not settings.enabled or len(enabled_settings) > 1)
				self.enabled[output].connect('toggled', self.enabled_toggled, settings)
				vbox2.pack_start(self.enabled[output])

			outputs_hbox.pack_start(frame, False, True, 0)
			hbox = g.HBox(False, 4)
			vbox.pack_start(hbox, False, True, 0)
			label = g.Label(_('Resolution: '))
			sg.add_widget(label)
			label.set_alignment(1, 0.5)
			hbox.pack_start(label, False, True, 0)
			self.resolutions[output] = g.OptionMenu()
			hbox.pack_start(self.resolutions[output], True, True, 0)

			menu = g.Menu()
			self.resolutions[output].set_menu(menu)
			for s in settings:
				item = g.MenuItem(str(s))
				menu.append(item)
				item.show()
			self.resolutions[output].connect('changed', self.show_details, settings)

			hbox = g.HBox(False, 4)
			vbox.pack_start(hbox, False, True, 0)
			label = g.Label(_('Refresh Rate: '))
			sg.add_widget(label)
			label.set_alignment(1, 0.5)
			hbox.pack_start(label, False, True, 0)
			self.refresh_rates[output] = g.OptionMenu()
			hbox.pack_start(self.refresh_rates[output])
			self.refresh_rates[output].connect('changed',
									  self.refresh_rate_changed, settings)

			menu = g.Menu()
			self.refresh_rates[output].set_menu(menu)
			i = 0
			current = settings.current
			if current is not None:
				if current.current_r is not None:
					i = current.res.index(current.current_r)
				if current.preferred_r is not None:
					i = current.res.index(current.preferred_r)
			self.refresh_rates[output].set_history(i)

			self.physical_size[output] = Field(_('Physical size: '), sg)
			vbox.pack_start(self.physical_size[output], False, True, 0)

			if settings.output_index > 0:
				hbox = g.HBox(False, 4)
				vbox.pack_start(hbox, False, True, 0)
				self.directions[output] = g.OptionMenu()
				sg.add_widget(self.directions[output])
				hbox.pack_start(self.directions[output], False, True, 0)
				menu = g.Menu()
				self.directions[output].set_menu(menu)
				menu.append(g.MenuItem(_('Same as')))
				menu.append(g.MenuItem(_('Left of')))
				menu.append(g.MenuItem(_('Right of')))
				menu.append(g.MenuItem(_('Above')))
				menu.append(g.MenuItem(_('Below')))
				self.directions[output].set_history(
					direction_strings.get(settings.direction, 0))
				self.directions[output].connect("changed", self.direction_changed,
									settings)

				self.other_outputs[output] = g.OptionMenu()
				hbox.pack_start(self.other_outputs[output])
				menu = g.Menu()
				self.other_outputs[output].set_menu(menu)
				self.other_output_strings[output] = [
					other_output for other_output in self.settings if other_output != output
				]
				for other_output in self.other_output_strings[output]:
					item = g.MenuItem(other_output)
					menu.append(item)
					if settings.other_output is None:
						settings.other_output = other_output
				self.other_outputs[output].set_history(
					self.other_output_strings[output].index(settings.other_output)
				)
				self.other_outputs[output].connect("changed", self.other_output_selected,
									   settings)

			try:
				i = settings.index(settings.current)
			except (ValueError, KeyError):
				try:
					i = settings.index(settings.preferred)
				except (ValueError, KeyError):
					i = 0
			self.resolutions[output].set_history(i)

			vbox.set_sensitive(settings.enabled)

		self.vbox.show_all()

	def direction_changed(self, directions, settings):
		direction = directions.get_history()
		settings.direction = direction_strings[direction]

	def other_output_selected(self, other_outputs, settings):
		other_output = self.other_output_strings[settings.output][other_outputs.get_history()]
		settings.other_output = other_output

	def refresh_rate_changed(self, refresh_rates, settings):
		current = settings.current
		current.current_r = current.res[refresh_rates.get_history()]

	def enabled_toggled(self, checkbutton, settings):
		settings.enabled = checkbutton.get_active()
		enabled_checkbuttons = [
			button for button in self.enabled.itervalues()
			if button.get_active()
		]
		if len(enabled_checkbuttons) == 1:
			enabled_checkbuttons[0].set_sensitive(False)
		else:
			for checkbutton in self.enabled.itervalues():
				checkbutton.set_sensitive(True)

		self.settings_vboxes[settings.output].set_sensitive(settings.enabled)

	def show_details(self, resolutions, settings):
		settings.current = current = settings[resolutions.get_history()]
		phy_size = '%s x %s' % (settings.phy_width, settings.phy_height)
		self.physical_size[settings.output].value.set_text(phy_size)
		menu = g.Menu()
		self.refresh_rates[settings.output].set_menu(menu)
		for refresh_rate in current.res:
			item = g.MenuItem('%s Hz' % refresh_rate)
			menu.append(item)
			item.show()
		self.refresh_rates[settings.output].set_history(
			current.res.index(current.current_r)
			if current.current_r is not None else 0
		)
	

try:
	import xrandr
	ResBox().show()
except:
	rox.report_exception()

rox.mainloop()
